# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.27.0
# source: users.sql
from typing import Optional

import sqlalchemy
import sqlalchemy.ext.asyncio

from . import models


REGISTER_TELEGRAM = """-- name: register_telegram \\:one
WITH tmp_id AS (
	INSERT INTO users (registred)
	VALUES (timezone('utc', now()))
	RETURNING id
)
INSERT INTO public.telegram(
	"telegramId", "userId", "chatId")
	SELECT :p1,
    id,
    :p2 FROM tmp_id
    RETURNING "userId"
"""


UPDATE_PERMISSIONS = """-- name: update_permissions \\:exec
INSERT INTO permissions ("userId", "permissions") 
VALUES (:p1, :p2)
ON CONFLICT ("userId") DO UPDATE 
  SET permissions = excluded.permissions
"""


VERIFY_USER_BY_ISIC = """-- name: verify_user_by_isic \\:exec
UPDATE users SET 
    "ISICNum"=:p2\\:\\:bigint,
    "facultyId"=:p3\\:\\:int
    WHERE "id"=:p1
"""


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def register_telegram(self, *, telegramId: int, chatId: int) -> Optional[int]:
        row = (await self._conn.execute(sqlalchemy.text(REGISTER_TELEGRAM), {"p1": telegramId, "p2": chatId})).first()
        if row is None:
            return None
        return row[0]

    async def update_permissions(self, *, userId: int, permissions: int) -> None:
        await self._conn.execute(sqlalchemy.text(UPDATE_PERMISSIONS), {"p1": userId, "p2": permissions})

    async def verify_user_by_isic(self, *, id: int, isicnum: int, facultyid: int) -> None:
        await self._conn.execute(sqlalchemy.text(VERIFY_USER_BY_ISIC), {"p1": id, "p2": isicnum, "p3": facultyid})
