# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.27.0
#   sqlc-gen-better-python v0.4.0
"""Module containing queries from file subjects.sql."""
from __future__ import annotations

__all__: collections.abc.Sequence[str] = (
    "QueryResults",
    "create_subject",
    "get_subject_by_id",
    "get_subject_by_semester",
    "get_subject_by_semester_faculty_stage",
    "get_subjects",
    "get_subjects_by_faculty",
    "get_subjects_by_stage",
)

import typing

if typing.TYPE_CHECKING:
    import asyncpg
    import asyncpg.cursor
    import collections.abc

    QueryResultsArgsType: typing.TypeAlias = int | float | str | memoryview

    ConnectionLike: typing.TypeAlias = asyncpg.Connection[asyncpg.Record] | asyncpg.pool.PoolConnectionProxy[asyncpg.Record]

from . import models


CREATE_SUBJECT: typing.Final[str] = """-- name: createSubject :one
INSERT INTO subjects ("name", "facultyId", "aisid", "stage", "semester", "aisCode")
VALUES ($1,$2,$3,$4,$5,$6)
RETURNING "id"
"""

GET_SUBJECT_BY_ID: typing.Final[str] = """-- name: getSubjectById :one
SELECT id, name, "facultyId", aisid, stage, semester, "aisCode" FROM subjects WHERE "id"=$1
"""

GET_SUBJECT_BY_SEMESTER: typing.Final[str] = """-- name: getSubjectBySemester :many
SELECT id, name, "facultyId", aisid, stage, semester, "aisCode" FROM subjects WHERE "semester"=$1
"""

GET_SUBJECT_BY_SEMESTER_FACULTY_STAGE: typing.Final[str] = """-- name: getSubjectBySemesterFacultyStage :many
SELECT id, name, "facultyId", aisid, stage, semester, "aisCode" FROM subjects WHERE "semester"=$1 AND "facultyId"=$2 AND "stage"=$3
"""

GET_SUBJECTS: typing.Final[str] = """-- name: getSubjects :many
SELECT id, name, "facultyId", aisid, stage, semester, "aisCode" FROM subjects
"""

GET_SUBJECTS_BY_FACULTY: typing.Final[str] = """-- name: getSubjectsByFaculty :many
SELECT id, name, "facultyId", aisid, stage, semester, "aisCode" FROM subjects WHERE "facultyId"=$1
"""

GET_SUBJECTS_BY_STAGE: typing.Final[str] = """-- name: getSubjectsByStage :many
SELECT id, name, "facultyId", aisid, stage, semester, "aisCode" FROM subjects WHERE "stage"=$1
"""


T = typing.TypeVar("T")

class QueryResults(typing.Generic[T]):
    """Helper class that allows both iteration and normal fetching of data from the db."""

    __slots__ = ("_args", "_conn", "_cursor", "_decode_hook", "_iterator", "_sql")

    def __init__(
        self,
        conn: ConnectionLike,
        sql: str,
        decode_hook: collections.abc.Callable[[asyncpg.Record], T],
        *args: QueryResultsArgsType,
    ) -> None:
        """Initialize the QueryResults instance.

        Args:
            conn:
                The connection object of type `ConnectionLike` used to execute queries.
            sql:
                The SQL statement that will be executed when fetching/iterating.
            decode_hook:
                A callback that turns an `asyncpg.Record` object into `T` that will be returned.
            *args:
                Arguments that should be sent when executing the sql query.
        """
        self._conn = conn
        self._sql = sql
        self._decode_hook = decode_hook
        self._args = args
        self._cursor: asyncpg.cursor.CursorFactory[asyncpg.Record] | None = None
        self._iterator: asyncpg.cursor.CursorIterator[asyncpg.Record] | None = None

    def __aiter__(self) -> QueryResults[T]:
        """Initialize iteration support for `async for`.

        Returns:
            Self as an asynchronous iterator.
        """
        return self

    def __await__(
        self,
    ) -> collections.abc.Generator[None, None, collections.abc.Sequence[T]]:
        """Allow `await` on the object to return all rows as a fully decoded sequence.

        Returns:
            A sequence of decoded objects of type `T`.
        """
        async def _wrapper() -> collections.abc.Sequence[T]:
            result = await self._conn.fetch(self._sql, *self._args)
            return [self._decode_hook(row) for row in result]
        return _wrapper().__await__()

    async def __anext__(self) -> T:
        """Yield the next item in the query result using an asyncpg cursor.

        Returns:
            The next decoded result of type `T`.

        Raises:
            StopAsyncIteration: When no more records are available.
        """
        if self._cursor is None or self._iterator is None:
            self._cursor = self._conn.cursor(self._sql, *self._args)
            self._iterator = self._cursor.__aiter__()
        try:
            record = await self._iterator.__anext__()
        except StopAsyncIteration:
            self._cursor = None
            self._iterator = None
            raise
        return self._decode_hook(record)

async def create_subject(conn: ConnectionLike, *, name: str, facultyId: int, aisid: int, stage: int, semester: int, aisCode: str) -> int | None:
    """Fetch one from the db using the SQL query with `name: createSubject :one`.

    Args:
        conn:
            Connection object of type `ConnectionLike` used to execute the query.
        name: str.
        facultyId: int.
        aisid: int.
        stage: int.
        semester: int.
        aisCode: str.

    Returns:
        Result of type `int` fetched from the db. Will be `None` if not found.
    """
    row = await conn.fetchrow(CREATE_SUBJECT, name, facultyId, aisid, stage, semester, aisCode)
    if row is None:
        return None
    return row[0]


async def get_subject_by_id(conn: ConnectionLike, *, id_: int) -> models.Subject | None:
    """Fetch one from the db using the SQL query with `name: getSubjectById :one`.

    Args:
        conn:
            Connection object of type `ConnectionLike` used to execute the query.
        id_: int.

    Returns:
        Result of type `models.Subject` fetched from the db. Will be `None` if not found.
    """
    row = await conn.fetchrow(GET_SUBJECT_BY_ID, id_)
    if row is None:
        return None
    return models.Subject(id=row[0], name=row[1], facultyId=row[2], aisid=row[3], stage=row[4], semester=row[5], aisCode=row[6]   )


def get_subject_by_semester(conn: ConnectionLike, *, semester: int) -> QueryResults[models.Subject]:
    """Fetch many from the db using the SQL query with `name: getSubjectBySemester :many`.

    Args:
        conn:
            Connection object of type `ConnectionLike` used to execute the query.
        semester: int.

    Returns:
        Helper class of type `QueryResults[models.Subject]` that allows both iteration and normal fetching of data from the db.
    """
    def _decode_hook(row: asyncpg.Record) -> models.Subject:
        return models.Subject(id=row[0], name=row[1], facultyId=row[2], aisid=row[3], stage=row[4], semester=row[5], aisCode=row[6])
    return QueryResults[models.Subject](conn, GET_SUBJECT_BY_SEMESTER, _decode_hook, semester)


def get_subject_by_semester_faculty_stage(conn: ConnectionLike, *, semester: int, facultyId: int, stage: int) -> QueryResults[models.Subject]:
    """Fetch many from the db using the SQL query with `name: getSubjectBySemesterFacultyStage :many`.

    Args:
        conn:
            Connection object of type `ConnectionLike` used to execute the query.
        semester: int.
        facultyId: int.
        stage: int.

    Returns:
        Helper class of type `QueryResults[models.Subject]` that allows both iteration and normal fetching of data from the db.
    """
    def _decode_hook(row: asyncpg.Record) -> models.Subject:
        return models.Subject(id=row[0], name=row[1], facultyId=row[2], aisid=row[3], stage=row[4], semester=row[5], aisCode=row[6])
    return QueryResults[models.Subject](conn, GET_SUBJECT_BY_SEMESTER_FACULTY_STAGE, _decode_hook, semester, facultyId, stage)


def get_subjects(conn: ConnectionLike) -> QueryResults[models.Subject]:
    """Fetch many from the db using the SQL query with `name: getSubjects :many`.

    Args:
        conn:
            Connection object of type `ConnectionLike` used to execute the query.

    Returns:
        Helper class of type `QueryResults[models.Subject]` that allows both iteration and normal fetching of data from the db.
    """
    def _decode_hook(row: asyncpg.Record) -> models.Subject:
        return models.Subject(id=row[0], name=row[1], facultyId=row[2], aisid=row[3], stage=row[4], semester=row[5], aisCode=row[6])
    return QueryResults[models.Subject](conn, GET_SUBJECTS, _decode_hook)


def get_subjects_by_faculty(conn: ConnectionLike, *, facultyId: int) -> QueryResults[models.Subject]:
    """Fetch many from the db using the SQL query with `name: getSubjectsByFaculty :many`.

    Args:
        conn:
            Connection object of type `ConnectionLike` used to execute the query.
        facultyId: int.

    Returns:
        Helper class of type `QueryResults[models.Subject]` that allows both iteration and normal fetching of data from the db.
    """
    def _decode_hook(row: asyncpg.Record) -> models.Subject:
        return models.Subject(id=row[0], name=row[1], facultyId=row[2], aisid=row[3], stage=row[4], semester=row[5], aisCode=row[6])
    return QueryResults[models.Subject](conn, GET_SUBJECTS_BY_FACULTY, _decode_hook, facultyId)


def get_subjects_by_stage(conn: ConnectionLike, *, stage: int) -> QueryResults[models.Subject]:
    """Fetch many from the db using the SQL query with `name: getSubjectsByStage :many`.

    Args:
        conn:
            Connection object of type `ConnectionLike` used to execute the query.
        stage: int.

    Returns:
        Helper class of type `QueryResults[models.Subject]` that allows both iteration and normal fetching of data from the db.
    """
    def _decode_hook(row: asyncpg.Record) -> models.Subject:
        return models.Subject(id=row[0], name=row[1], facultyId=row[2], aisid=row[3], stage=row[4], semester=row[5], aisCode=row[6])
    return QueryResults[models.Subject](conn, GET_SUBJECTS_BY_STAGE, _decode_hook, stage)
